import lookup from 'lookup';
import id from 'id';

export default class Node {

  #identity = {
    id: null,
    name: null,
  };

  #traversal = {
    root: null,
    parent: null,
    objects: [],
  }

  #content = {

  }

  constructor(setup){
    this.id = setup.id || id(); // let the system set this
    this.name = setup.name || id();
  }

  // Identity

  get id(){ return this.#identity.id; }
  set id(id){ this.#identity.id = id; lookup.byId[id] = id; }

  get name(){ return this.#identity.name; }
  set name(name){ this.#identity.name = name; lookup.byName[name] = name; }

  get root(){return lookup.byId.root}
  set root(data){/*noope*/}

  set parent(node){ this.#traversal.parent = node.id; }
  get parent(){ return lookup.byId[this.#traversal.parent]; }

  get path(){
      const response = [];
      let current = this;
      while(current.parent){
        response.unshift(current.name);
        current = current.parent;
      }
      return response.join('/');
  }
  set path(data){/*noope*/}

  // Traversal




  // calc relative to parent and this
  get previous(){}
  set previous(data){/*noope*/}
  get next(){}
  set next(data){/*noope*/}

  // find a child matching a wildcard ** or *
  get wild(){}
  set wild(data){/*noope*/}



  get objects(){
    return this.#traversal.objects;
  }
  set objects(data){/*noope*/}

  resolve(pathString){
    const pathArray = pathString.split(/\.|\//).filter(i=>i);
    let current = this;
    for(const name of pathArray){
      const resolved = current.object(name);
      if(resolved){
        current = resolved;
      }else{
        return null;
      }
    }
    return current;

  }

  object(name){
    return this.#traversal.objects.filter(object=>object.name === name).pop();
  }

  add(node){

    const exists = this.object(node.name);
    if (exists) throw new Error('Object with that name alrealy exists.')

    node.parent = this;
    this.#traversal.objects.push(node);
  }

  make(pathString){

    const pathArray = pathString.split(/\.|\//).filter(i=>i);
    let current = this;

    for(const name of pathArray){

      const existing = current.object(name);

      if(existing){
        //console.log(`Node ${current.name}(${current.path}) did! have ${existing.name}: ${current.objects.map(i=>i.name).join(', ')}`)
        //const node = new Node({name});
        //existing.add(node);
        current = existing;
      }else{
        //console.log(`Node ${current.name}(${current.path}) did not have ${name}: ${current.objects.map(i=>i.name).join(', ')}`)
        const node = new Node({name});
        current.add(node);
        current = node;
      }

    }
    return current;
  }

  // Serialization

  // Content

}
